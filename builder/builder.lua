-- Set module paths

package.path = package.path .. ";utils/?.lua;builder/?.lua;builder/gen/?.lua;builder/ui/?.lua;builder/option/?.lua"
local utils = require "utils"
local gen = require "gen"
local sf = string.format

--local cf = require "builder.platforms.lpc24xx"
--local c = cf.cpu_list.lpc2468
local cf = require "builder.platforms.lm3s"
local c = cf.cpu_list.lm3s8962

-- First create all I/O generators
local io_gens = { 'gen-io-pio', 'gen-io-pwm', 'gen-io-uart', 'gen-io-timer', 'gen-io-eth', 'gen-io-spi' }
utils.foreach( io_gens, function( k, v ) require( v ).new( c ) end )

-------------------------------------------------------------------------------
-- Dependency-related functions

local function _gen( comp )  
  return assert( gen.find_generator( comp ), sf( "Unable to find generator for component %s", comp ) )
end

-- Compute all the dependencies of a component
local function get_all_deps( comp )
  local deps = {}
  local explored = {}
  local function dfs( c )
    for i = 1, #c:get_deps() do
      local d = c:get_deps()[ i ]
      if not explored[ d ] then
        explored[ d ] = true
        dfs( _gen( d ) )
      end
    end
  end
  dfs( comp )
  utils.foreach( explored, function( k, v ) table.insert( deps, k ) end )
  return deps
end

-- Compute all dependencies (forward and reverse) for all components
local function get_global_deps( complist )
  local forward, reverse = {}, {}
  -- First forward dependencies
  utils.foreach( complist, function( k, v ) forward[ v ] = get_all_deps( _gen( v ) ) end )
  -- Then reverse dependencies
  for c, deplist in pairs( forward ) do
    for _, dep in pairs( deplist ) do
      if not reverse[ dep ] then reverse[ dep ] = {} end
      if not utils.array_element_index( reverse[ dep ], c ) then
        table.insert( reverse[ dep ], c )
      end
    end
  end
  return forward, reverse
end

-------------------------------------------------------------------------------
-- Components initialization

local comp_gens =
{
  'gen-comp-vtmr', 'gen-comp-console', 'gen-comp-xmodem',
  'gen-comp-romfs', 'gen-comp-term', 'gen-comp-linenoise',
  'gen-comp-tcpip', 'gen-comp-telnet', 'gen-comp-dhcpc',
  'gen-comp-dnsc', 'gen-comp-mmcfs', 'gen-comp-shell'
}
utils.foreach( comp_gens, function( k, v ) require( v ).new( cf ) end )

-- Initialize all generators
utils.foreach( comp_gens, function( k, v ) _gen( v ):init() end )

-------------------------------------------------------------------------------
-- Load/ save state

local function save_state( clist, outfile )
  -- Save the state of all generators to a file
  local conffile = assert( io.open( outfile, "wb" ) )
  conffile:write( [[ -- Automatically generated component configuration file
local conftable = {
]] )
  for k, v in pairs( comp_gens ) do
    local g = _gen( v )
    conffile:write( sf( '  [ "%s" ] = %s,\n', g:get_name(), table.tostring( g:get_conf() ) ) )
  end
  conffile:write( [[
  }

  return conftable
]] )
  conffile:close()
end

local function load_state( infile )
  if not utils.is_file( infile ) then return false end
  local conftable = dofile( infile )
  for k, v in pairs( conftable ) do
    local g = _gen( k )
    g:load_conf( v )
  end
  return true
end

-------------------------------------------------------------------------------
-- Generator utilities

-- Return the list of all the given components in the order in which they
-- should be generated by performing explicit dependency checks on them.
local function get_gen_order( comps )
  comps = utils.linearize_array( comps )
  local depcount, maxlevel = {}, 0
  table.foreach( comps, function( k, v ) depcount[ v ] = 0 end )
  -- Get dependency list for all components and count the number of times
  -- a component is listed as a dependency
  for k, v in pairs( comps ) do
    local deps = fw_deps[ v ] or {}
    for _, depname in pairs( deps ) do
      depcount[ depname ] = depcount[ depname ] + 1
      maxlevel = depcount[ depname ] > maxlevel and depcount[ depname ] or maxlevel
    end
  end
  local ordered = {}
  for i = maxlevel, 0, -1 do
    for k, v in pairs( depcount ) do
      if v == i then
        table.insert( ordered, k )
      end
    end
  end
  return ordered
end

-------------------------------------------------------------------------------
-- Configurator functions

--local ui = require "builder.ui.ui-cmdline".new_ui()
local ui = require "builder.ui.ui-dialog".new_ui()

-- Build a list of components and their respective state
local function build_component_list( clist )
  local all = {}
  -- Iterate through clist and get all the components and their state
  utils.foreach( clist, function( k, v )
    local g = _gen( v )
    table.insert( all, sf( "[%s] %s", g:get_state() == "enabled" and "E" or "D", g:get_friendly_name() ) )
  end ) 
  return all
end

-- Return all the pending notifications
local function get_pending_notifications()
  local s = ''
  for k, v in pairs( comp_gens ) do
    local g = _gen( v )
    local n = g:get_last_notification()
    if #n > 0 then
      s = s .. sf( "%s: %s", g:get_friendly_name(), n )
      if s:sub( -1, -1 ) ~= "\n" then s = s .. "\n" end
    end
  end
  return #s > 0 and s
end

-- Builder action: show list of dependencies
local function act_show_deps( g )
  -- Check explicit dependencies first
  local s = g:get_explicit_deps_string() or ''
  if s then return s end
  -- Show all dependencies
  table.foreach( fw_deps[ g:get_name() ], function( k, depname )
    local dg = _gen( depname )
    s = s .. sf( 'Component depends on %s which is currently %s.\n', dg:get_friendly_name(), dg:get_state() )
  end )
  return s:sub( 1, -2 )
end

-- Builder action: configure component
local function act_configure( g )
  local prev_state = g:get_state()
  ui:configure( g )
  if g:get_state() ~= prev_state then
    g.notify_all( g:get_name(), g:get_state() )
    return get_pending_notifications()
  end
end

-- Builder action: enable
local function act_enable( g )
  -- Helper: try to enable a component, configure it if not possible
  local function try_enable()
    -- First simulate the enable, get confirmation from user if needed
    g.notify_all( g:get_name(), 'enabled' )
    local reason = get_pending_notifications()
    g.execute_notification_actions( true )
    if type( reason ) == "string" then
      reason = "WARNING: enabling this component would have side effects:\n\n" .. reason .. "\nAre you sure you want to enable this component?"
      if ui:ask_yesno( reason ) == "n" then return end
    end

    if not g:enable( true ) then
      ui:configure( g )
      if not g:enable( true ) then
        error( sf( "Internal error? Unable to enable component '%s' even after it was configured", g:get_name() ) )
      end
    end
    g.notify_all( g:get_name(), g:get_state() )
    g.execute_notification_actions()
    get_pending_notifications()
    return true
  end

  local can_enable = g:can_enable()
  local reason = "ERROR: the component can't be enabled\n\n"
  if not can_enable then
    return reason .. "This is most likely a generator error, check the generator implementation."
  end
  local deps = fw_deps[ g:get_name() ]

  -- Check the extra dependencies first
  local e, msg = g:check_explicit_deps()
  if not e then return reason .. "\n" .. msg end

  -- No dependencies? That makes me a happy bunny
  if #deps == 0 then return try_enable() end

  -- Check deps
  reason = ""
  for k, depname in pairs( deps ) do
    local dg = _gen( depname )
    if not dg:is_enabled() then 
      if dg:is_io_generator() then
        reason = reason .. sf( "Error: component %s depends on an I/O peripheral (%s) which isn't present or doesn't have a driver.\n", g:get_friendly_name(), dg:get_friendly_name() )
        break
      end
      reason = reason .. sf( "Error: component %s (needed by '%s') is not enabled.\n", dg:get_friendly_name(), g:get_friendly_name() )
    end
  end
  if reason ~= "" then
    return reason .. "\nError: the component can't be enabled"
  end

  -- Everything OK, enable component and notify the rest of the components of this change
  return try_enable()
end

local function act_disable( g )
  local can_disable = g:can_disable()
  local reason = "ERROR: the component can't be disabled\n\n"
  if not can_disable then
    return reason .. "This is most likely a generator error, check the generator implementation."
  end

  -- Check reverse deps
  reason = ""
  local revdeps = rev_deps[ g:get_name() ] or {}
  local to_disable = {}
  for k, depname in pairs( revdeps ) do
    local rdg = _gen( depname )
    if rdg:is_enabled() then
      reason = reason .. sf( "Warning: component '%s' (%s) depends on this component and will be automatically disabled\n", rdg:get_name(), rdg:get_friendly_name() )
      table.insert( to_disable, depname )
    end
  end

  -- If there are any reverse dependencies ask the user for confirmation
  if #reason > 0 then
    reason = reason .. "\nAre you sure you want to disable this component?"
    if ui:ask_yesno( reason ) == "n" then return end
  end

  -- Simulate disabling the component, get notifications and ask user for confirmation if needed
  g.notify_all( g:get_name(), 'disabled' )
  reason = get_pending_notifications()
  g.execute_notification_actions( true )
  if type( reason ) == "string" then
    reason = "WANING: disabling this component would have side effects:\n\n" .. reason .. "\nAre you sure you want to disable this component?"
    if ui:ask_yesno( reason ) == "n" then return end
  end

  -- Disable the component and its reverse dependencies now
  utils.foreach( to_disable, function( k, v ) _gen( v ):enable( false ) end )
  g:enable( false )

  -- Notify all the other components and execute pending actions if needed
  g.notify_all( g:get_name(), g:get_state() )
  g.execute_notification_actions()
  get_pending_notifications()
  return true
end

-- Builder action: show configuration
local function act_show_conf( g )
  local opts = g:get_options()
  local conf = ""
  for i = 1, #opts do
    local o = opts[ i ]
    conf = conf .. sf( "%s (%s): %s\n\n", o:get_help(), o:get_name(), o:get_value() or "not configured" )
  end
  return conf:sub( 1, -2 )
end

-- Build a list of actions corresponding to the state of a component
local function build_action_list( cgen )
  local act_show_conf = { func = act_show_conf, text = 'Show configuration' }
  local act_disable = { func = act_disable, text = 'Disable component' }
  local act_enable = { func = act_enable, text = 'Enable component' }
  local act_configure = { func = act_configure, text = 'Configure component' }
  local act_show_deps = { func = act_show_deps, text = "Show dependencies" }
  local opts = cgen:get_options()
  local deps = cgen:get_deps()
  local acttable = { 
    enabled = { act_configure, act_show_conf, act_disable, act_show_deps },
    disabled = { act_enable, act_show_deps }
  }
  local actions = assert( acttable[ cgen:get_state() ] )
  -- Filter unneeded actions
  for k, v in pairs( actions ) do
    if v == act_show_conf and #opts == 0 then
      v = nil
    elseif v == act_configure and #opts == 0 then
      v = nil
    elseif v == act_show_deps and #deps == 0 and not cgen:get_explicit_deps_string() then
      v = nil
    end
    actions[ k ] = v
  end
  local realact = {}
  -- Return the above table without nils
  table.foreach( actions, function( k, v ) table.insert( realact, v ) end )
  return realact
end

-------------------------------------------------------------------------------
-- Main entry point

-- Compute all dependencies in global tables
fw_deps, rev_deps = get_global_deps( comp_gens )

-- Load previous state
load_state( "tempconf.lua" )

-- Build the first level menu
local base_menu =
{
  { title = "Generic components", comps = { 'gen-comp-vtmr', 'gen-comp-console', 'gen-comp-xmodem', 'gen-comp-term', 'gen-comp-linenoise', 'gen-comp-shell' } },
  { title = "Networking", comps = { 'gen-comp-tcpip', 'gen-comp-telnet', 'gen-comp-dhcpc', 'gen-comp-dnsc' }, validator = function()
    local g = _gen( 'gen-io-eth' )
    return g:is_enabled()
  end },
  { title = "File systems", comps = { 'gen-comp-romfs', 'gen-comp-mmcfs' } }
}
local base_idx = 1
local clist

-- Enter the configurator loop
while true do
  if clist then
    -- Show the list of components and their state, ask for an action
    local l = build_component_list( clist )
    local res = ui:menu( l, 1, "Main configurator menu", "Choose a component to configure:\n" )
    if res == 'exit' then
      clist = nil
    else
      -- We have a component, now find what we can do with it
      local g = _gen( clist[ res ] )
      while true do
        l = build_action_list( g )
        res = ui:menu( l, 1, "Component: " .. g:get_friendly_name(), g:get_help() .. "\nChoose an action:\n" )
        if res == "exit" then break end
        local func = l[ res ].func
        res = func( g )
        if type( res ) == "string" then ui:info( res, "Component: " .. g:get_friendly_name() ) end
      end
    end
  else -- Main menu
    local optlist = {}
    table.foreach( base_menu, function( k, v )
      if not v.validator or v.validator() then
        table.insert( optlist, sf( "%s (%d %s)", v.title, #v.comps, #v.comps == 1 and "item" or "items" )  )
      end
    end )
    local res = ui:menu( optlist, 1, "Main configurator menu", "Choose a component group:\n" )
    if res == "exit" then break end
    clist = base_menu[ res ].comps
  end
end

-- Save current state
save_state( comp_gens, "tempconf.lua" )

-- Generate everything in tempconf.h
local genfile = assert( io.open( "tempconf.h", "wb" ) )

local ordered_gens = get_gen_order( { io_gens, comp_gens } )
for k, v in pairs( ordered_gens ) do
  local g = _gen( v )
  if g:is_enabled() or g:is_io_generator() then
    g:generate( genfile )
  else
    print( sf( "WARNING: component '%s' is not configured, its configuration will not be generated", g:get_friendly_name() ) )
  end
end

genfile:close()
